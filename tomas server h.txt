//WebServer.h

#pragma once

#include <WinSock2.h>
#pragma comment(lib, "ws2_32.lib")
#include <list>

/*
-----------------------------------------------------------------------
WEBSERVER INFO

Using port: 8080

Hemsidemapp:
../Webpage/

Vad servern klarar av:
* Ladda html-filer frln fil
* Ladda bilder frln fil (endast support för .ico och .jpg) (maxstorlek 10 megabyte)
* Safeguardar mot Get-reqs som innehlller ".."
* Stöder keep-alive (och defaultar till det)

Testad och borde fungera till senare versioner av:
* Google Chrome
* Google Chrome frln mobil
* Mozilla Firefox
* Internet Explorer
-----------------------------------------------------------------------
*/

class WebServer
{
private:
	enum HTTPcode
	{
		HTTPCODE_OK = 200,
		HTTPCODE_REFUSE = 403,
		HTTPCODE_NOTFOUND = 404,
	};

	enum ContentType
	{
		HTTPCONTENTTYPE_HTML,
		HTTPCONTENTTYPE_IMAGEJPG,
		HTTPCONTENTTYPE_IMAGEICO,
		HTTPCONTENTTYPE_NONE,
	};

	struct Header
	{
		Header(const HTTPcode &p_httpcode, const ContentType &p_contenttype)
		{
			m_httpcode = p_httpcode;
			m_contenttype = p_contenttype;
		}
		HTTPcode m_httpcode;
		ContentType m_contenttype;
	};

	struct Client
	{
		Client(){};
		Client(SOCKET p_socket, sockaddr_in p_addr, unsigned int p_timestamp, bool p_bKeepAlive = false)
		{
			m_socket = p_socket;
			m_addr = p_addr;
			bKeepAlive = p_bKeepAlive;
			m_timestamp = p_timestamp;
		}
		sockaddr_in m_addr;
		SOCKET m_socket;
		bool bKeepAlive;
		unsigned int m_timestamp;
	};

	struct HTMLPage
	{
		HTMLPage(const std::string &p_adress = "", const std::string &p_content = "")
		{
			adress = p_adress;
			content = p_content;
		}
		std::string adress;
		std::string content;
	};

	WSAData m_wsadata;

	Client m_client_server;
	std::list < Client > m_clients_remote;
	std::list < HTMLPage > m_html_pages;

	bool m_bKeepAliveDefault;

	void PrintAdress(sockaddr_in p_addr);

	bool RemoteSocketInList(const SOCKET &p_socket);
	void RemoteClientAdd(Client p_client);
	void RemoteClientUpdateTimeout(const SOCKET &p_socket);
	void RemoteClientsRecv();
	void RemoteClientsAliveCheck();
	
	bool ClientHasData(const Client &p_client);

	void AcceptConnection(SOCKET &p_socket, sockaddr_in &p_remote);

	void HandleRequest(Client &p_client);
	bool GETRequestIsSafe(const std::string &p_addr_req);
	bool HTMLPageLoad(const std::string &p_addr_req);
	bool HTMLPageSend(const SOCKET &p_socket, const std::string &p_addr_req, const bool &p_send_404 = false);
	bool ImageSend(const SOCKET &p_socket, const std::string &p_addr_req, const ContentType &p_imagetype);
	void SendMsg(const SOCKET &p_socket, char* p_msg, const int &p_iMsgLength, const Header &p_xHeader);

	std::string asString_HeaderCode(const HTTPcode &e_code);
	std::string asString_HeaderContentType(const ContentType &e_contenttype);
	std::string asString_Header(const int &p_iContLength, const Header &p_xHeader);

public:
	WebServer();
	~WebServer(){};

	bool Initialize();
	void Shutdown();
	void RunLoop();

	void SetKeepAliveDefault(const bool &p_bKeepAlive);
};